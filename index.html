<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Timelines for Sam</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.5rem;
      color: #a0a0ff;
    }

    .controls {
      text-align: center;
      margin-bottom: 30px;
    }

    .btn {
      background: #4a4a8a;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: background 0.2s;
    }

    .btn:hover {
      background: #6a6aaa;
    }

    .timelines {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
    }

    .timeline {
      background: #2a2a4a;
      border-radius: 10px;
      padding: 15px;
      position: relative;
      user-select: none;
      display: flex;
      gap: 12px;
      cursor: grab;
    }

    .timeline.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .timeline.drag-over {
      outline: 2px dashed #a0a0ff;
      outline-offset: 2px;
    }

    .timeline-content {
      width: 195px;
    }

    .timeline-sidebar {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .sidebar-btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .sidebar-btn.delete {
      background: #8a4a4a;
      color: #fff;
    }

    .sidebar-btn.delete:hover {
      background: #aa6a6a;
    }

    .sidebar-btn.ignore {
      background: #4a4a6a;
      color: #fff;
      font-size: 12px;
      font-weight: bold;
    }

    .sidebar-btn.ignore:hover {
      background: #6a6a8a;
    }

    .sidebar-btn.ignore.active {
      background: #6a6a3a;
      color: #aa6;
    }

    .sidebar-btn:not(.delete):not(.ignore) {
      background: #4a4a6a;
      color: #fff;
    }

    .sidebar-btn:not(.delete):not(.ignore):hover {
      background: #6a6a8a;
    }

    .sidebar-btn.clear-all {
      margin-top: auto;
    }

    .color-menu {
      position: absolute;
      background: #1a1a2e;
      border: 1px solid #4a4a6a;
      border-radius: 6px;
      padding: 6px;
      display: flex;
      gap: 4px;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }

    .color-option {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
    }

    .color-option:hover {
      border-color: #fff;
    }

    .timeline-header {
      margin-bottom: 10px;
    }

    .timeline-title {
      font-weight: bold;
      color: #a0a0ff;
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 3px;
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      height: 22px;
      line-height: 18px;
    }

    .timeline-title:hover {
      background: #3a3a5a;
    }

    .timeline-title-input {
      font-weight: bold;
      color: #a0a0ff;
      background: #3a3a5a;
      border: 1px solid #6a6a8a;
      border-radius: 3px;
      padding: 1px 4px;
      font-size: inherit;
      font-family: inherit;
      width: 100%;
      box-sizing: border-box;
      height: 22px;
      line-height: 18px;
    }

    .timeline-title-input:focus {
      outline: none;
      border-color: #a0a0ff;
    }


    .grid {
      display: grid;
      grid-template-columns: auto repeat(4, 40px);
      gap: 3px;
    }

    .col-label, .row-label {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #888;
      font-weight: bold;
    }

    .col-label {
      height: 20px;
    }

    .row-label {
      width: 20px;
    }

    .cell {
      width: 40px;
      height: 40px;
      background: #3a3a5a;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
      border: 2px solid transparent;
    }

    .cell:hover {
      border-color: #fff;
    }

    .cell.green {
      background: #2d8a4a;
    }

    .cell.red {
      background: #8a2d2d;
    }

    .cell.solved-innocent {
      background: #3a3a5a;
      border-color: #2d8a4a;
      color: #2d8a4a;
      font-weight: bold;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cell.solved-criminal {
      background: #3a3a5a;
      border-color: #8a2d2d;
      color: #8a2d2d;
      font-weight: bold;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .legend {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 30px;
      font-size: 0.85rem;
      color: #888;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .legend-swatch {
      width: 16px;
      height: 16px;
      border-radius: 3px;
    }

    .legend-swatch.tag-green { background: #2d8a4a; }
    .legend-swatch.tag-red { background: #8a2d2d; }
    .legend-swatch.solved-i {
      background: #3a3a5a;
      border: 2px solid #2d8a4a;
      color: #2d8a4a;
      font-size: 10px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .legend-swatch.solved-c {
      background: #3a3a5a;
      border: 2px solid #8a2d2d;
      color: #8a2d2d;
      font-size: 10px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .keybinds {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
      margin-top: 15px;
      font-size: 0.8rem;
      color: #666;
    }

    .keybind {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    kbd {
      background: #3a3a5a;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 0.75rem;
      color: #aaa;
    }

    .evaluation {
      background: #2a2a4a;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      display: none;
    }

    .evaluation.visible {
      display: block;
    }

    .evaluation h3 {
      margin: 0 0 10px 0;
      color: #a0a0ff;
      font-size: 1rem;
    }

    .consensus-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .consensus-item {
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .consensus-item:hover {
      filter: brightness(1.2);
    }

    .consensus-item.green {
      background: #2d8a4a;
      color: #fff;
    }

    .consensus-item.red {
      background: #8a2d2d;
      color: #fff;
    }

    .no-consensus {
      color: #888;
    }
  </style>
</head>
<body>
  <h1>Timelines for Sam</h1>

  <div class="controls">
    <button class="btn" onclick="addTimeline()">+ New Timeline</button>
    <button class="btn" onclick="evaluateTimelines()">Evaluate</button>
    <button class="btn" style="background:#8a4a4a" onclick="clearAll()">Clear All</button>
  </div>

  <div id="evaluation" class="evaluation"></div>

  <div class="timelines" id="timelines"></div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch tag-green"></div>
      <span>Green Tag</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch tag-red"></div>
      <span>Red Tag</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch solved-i">I</div>
      <span>Solved Innocent</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch solved-c">C</div>
      <span>Solved Criminal</span>
    </div>
  </div>

  <div class="keybinds">
    <span class="keybind"><kbd>Q</kbd> Green Tag</span>
    <span class="keybind"><kbd>E</kbd> Red Tag</span>
    <span class="keybind"><kbd>A</kbd> Innocent</span>
    <span class="keybind"><kbd>D</kbd> Criminal</span>
    <span class="keybind"><kbd>Space</kbd> Clear</span>
    <span class="keybind"><kbd>Right Click</kbd> Clear</span>
  </div>

  <script>
    const cols = ['A', 'B', 'C', 'D'];
    const rows = [1, 2, 3, 4, 5];
    const states = ['', 'green', 'red', 'solved-innocent', 'solved-criminal'];
    const bgColors = ['#2a2a4a', '#2a5a2a', '#5a2a2a', '#2a4a5a', '#5a5a2a', '#2a5a5a', '#5a2a5a'];
    let timelines = []; // array of {name, cellStates, bgColor, ignored} objects

    function save() {
      localStorage.setItem('timelines', JSON.stringify(timelines));
    }

    function load() {
      const data = localStorage.getItem('timelines');
      if (data) {
        const parsed = JSON.parse(data);
        // migrate old format to new format
        timelines = parsed.map((t, i) => {
          if (Array.isArray(t)) {
            return { name: `Timeline ${i + 1}`, cellStates: t, bgColor: bgColors[0], ignored: false };
          }
          if (!t.bgColor) t.bgColor = bgColors[0];
          if (t.ignored === undefined) t.ignored = false;
          return t;
        });
        save(); // save migrated data
        timelines.forEach((t, i) => renderTimeline(i, t.cellStates, t.name, t.bgColor));
        evaluateTimelines();
      } else {
        addTimeline();
      }
    }

    function renderTimeline(index, cellStates = null, name = null, bgColor = null) {
      const container = document.getElementById('timelines');
      const displayName = name || `Timeline ${index + 1}`;
      const color = bgColor || bgColors[0];

      const timeline = document.createElement('div');
      timeline.className = 'timeline';
      timeline.dataset.index = index;
      timeline.style.background = color;
      timeline.draggable = true;

      timeline.oncontextmenu = (e) => {
        if (e.target.classList.contains('cell')) return;
        e.preventDefault();
        showColorMenu(index, e.clientX, e.clientY, timeline);
      };

      timeline.ondragstart = (e) => {
        timeline.classList.add('dragging');
        e.dataTransfer.setData('text/plain', index);
      };

      timeline.ondragend = () => {
        timeline.classList.remove('dragging');
        document.querySelectorAll('.timeline').forEach(t => t.classList.remove('drag-over'));
      };

      timeline.ondragover = (e) => {
        e.preventDefault();
        if (!timeline.classList.contains('dragging')) {
          timeline.classList.add('drag-over');
        }
      };

      timeline.ondragleave = () => {
        timeline.classList.remove('drag-over');
      };

      timeline.ondrop = (e) => {
        e.preventDefault();
        timeline.classList.remove('drag-over');
        const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
        const toIndex = index;
        if (fromIndex !== toIndex) {
          reorderTimeline(fromIndex, toIndex);
        }
      };

      let gridHTML = `
        <div class="timeline-content">
          <div class="timeline-header">
            <span class="timeline-title" onclick="editTimelineName(${index}, this)">${displayName}</span>
          </div>
          <div class="grid">
            <div></div>
      `;

      cols.forEach(col => {
        gridHTML += `<div class="col-label">${col}</div>`;
      });

      let cellIndex = 0;
      rows.forEach(row => {
        gridHTML += `<div class="row-label">${row}</div>`;
        cols.forEach(col => {
          const state = cellStates ? cellStates[cellIndex] : 0;
          const letter = state === 3 ? 'I' : state === 4 ? 'C' : '';
          gridHTML += `<div class="cell ${states[state]}" data-state="${state}" data-cell="${cellIndex}" onclick="cycleCell(event, this, ${index})" oncontextmenu="clearCell(event, this, ${index})">${letter}</div>`;
          cellIndex++;
        });
      });

      gridHTML += '</div>';
      gridHTML += '</div>';
      const ignoredClass = timelines[index]?.ignored ? ' active' : '';
      gridHTML += `
        <div class="timeline-sidebar">
          <button class="sidebar-btn delete" onclick="deleteTimeline(${index})" title="Delete">×</button>
          <button class="sidebar-btn ignore${ignoredClass}" onclick="toggleIgnore(${index})" title="Ignore in consensus">⊘</button>
          <button class="sidebar-btn" onclick="duplicateTimeline(${index})" title="Duplicate">⧉</button>
          <button class="sidebar-btn" onclick="clearTags(${index})" title="Clear tags">◔</button>
          <button class="sidebar-btn clear-all" onclick="clearTimeline(${index})" title="Clear all">⊠</button>
        </div>
      `;
      timeline.innerHTML = gridHTML;
      container.appendChild(timeline);
    }

    function addTimeline() {
      const cellStates = new Array(20).fill(0);
      const name = `Timeline ${timelines.length + 1}`;
      const bgColor = bgColors[0];
      timelines.push({ name, cellStates, bgColor, ignored: false });
      renderTimeline(timelines.length - 1, cellStates, name, bgColor);
      save();
      evaluateTimelines();
    }

    function showColorMenu(index, x, y, timelineEl) {
      closeColorMenu();
      const menu = document.createElement('div');
      menu.className = 'color-menu';
      menu.id = 'color-menu';

      bgColors.forEach(color => {
        const opt = document.createElement('div');
        opt.className = 'color-option';
        opt.style.background = color;
        opt.onclick = () => {
          timelines[index].bgColor = color;
          timelineEl.style.background = color;
          save();
          closeColorMenu();
        };
        menu.appendChild(opt);
      });

      document.body.appendChild(menu);
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';

      setTimeout(() => {
        document.addEventListener('click', closeColorMenu, { once: true });
      }, 0);
    }

    function closeColorMenu() {
      const menu = document.getElementById('color-menu');
      if (menu) menu.remove();
    }

    function toggleIgnore(index) {
      timelines[index].ignored = !timelines[index].ignored;
      save();
      rerender();
      evaluateTimelines();
    }

    function reorderTimeline(fromIndex, toIndex) {
      const [moved] = timelines.splice(fromIndex, 1);
      timelines.splice(toIndex, 0, moved);
      save();
      rerender();
    }

    function editTimelineName(index, element) {
      const currentName = timelines[index].name;
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'timeline-title-input';
      input.value = currentName;

      const finishEdit = () => {
        const newName = input.value.trim() || `Timeline ${index + 1}`;
        timelines[index].name = newName;
        save();
        const span = document.createElement('span');
        span.className = 'timeline-title';
        span.textContent = newName;
        span.onclick = () => editTimelineName(index, span);
        input.replaceWith(span);
      };

      input.onblur = finishEdit;
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          input.blur();
        } else if (e.key === 'Escape') {
          input.value = currentName;
          input.blur();
        }
      };

      element.replaceWith(input);
      input.focus();
      input.select();
    }

    function updateCellDisplay(cell, state) {
      cell.className = 'cell ' + states[state];
      if (state === 3) cell.textContent = 'I';
      else if (state === 4) cell.textContent = 'C';
      else cell.textContent = '';
    }

    function setCellState(timelineIndex, cellIndex, state) {
      timelines[timelineIndex].cellStates[cellIndex] = state;
      const cell = document.querySelector(`.timeline[data-index="${timelineIndex}"] .cell[data-cell="${cellIndex}"]`);
      if (cell) {
        cell.dataset.state = state;
        updateCellDisplay(cell, state);
      }
    }

    function cycleCell(e, cell, timelineIndex) {
      const cellIndex = parseInt(cell.dataset.cell);
      let state = parseInt(cell.dataset.state);
      state = (state + 1) % states.length;

      if (e.shiftKey) {
        timelines.forEach((_, i) => setCellState(i, cellIndex, state));
      } else {
        setCellState(timelineIndex, cellIndex, state);
      }
      save();
      evaluateTimelines();
    }

    function clearCell(e, cell, timelineIndex) {
      e.preventDefault();
      const cellIndex = parseInt(cell.dataset.cell);

      if (e.shiftKey) {
        timelines.forEach((_, i) => setCellState(i, cellIndex, 0));
      } else {
        setCellState(timelineIndex, cellIndex, 0);
      }
      save();
      evaluateTimelines();
    }

    function deleteTimeline(index) {
      timelines.splice(index, 1);
      save();
      rerender();
      evaluateTimelines();
    }

    function duplicateTimeline(index) {
      const orig = timelines[index];
      let newName;

      const defaultMatch = orig.name.match(/^Timeline (\d+)$/);
      if (defaultMatch) {
        // Default name - find next available Timeline number
        const existingNums = timelines
          .map(t => t.name.match(/^Timeline (\d+)$/))
          .filter(m => m)
          .map(m => parseInt(m[1]));
        let next = 1;
        while (existingNums.includes(next)) next++;
        newName = `Timeline ${next}`;
      } else {
        // Custom name - append incrementing number
        const baseName = orig.name.replace(/ \d+$/, '');
        const existingNums = timelines
          .filter(t => t.name === baseName || t.name.match(new RegExp(`^${baseName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')} \\d+$`)))
          .map(t => {
            const m = t.name.match(/ (\d+)$/);
            return m ? parseInt(m[1]) : 0;
          });
        const next = Math.max(0, ...existingNums) + 1;
        newName = `${baseName} ${next}`;
      }

      const copy = { name: newName, cellStates: [...orig.cellStates], bgColor: orig.bgColor, ignored: false };
      timelines.push(copy);
      renderTimeline(timelines.length - 1, copy.cellStates, copy.name, copy.bgColor);
      save();
      evaluateTimelines();
    }

    function clearTags(index) {
      timelines[index].cellStates = timelines[index].cellStates.map(s => (s === 1 || s === 2) ? 0 : s);
      save();
      rerender();
      evaluateTimelines();
    }

    function clearTimeline(index) {
      timelines[index].cellStates = new Array(20).fill(0);
      save();
      rerender();
      evaluateTimelines();
    }

    function clearAll() {
      timelines = [];
      document.getElementById('timelines').innerHTML = '';
      addTimeline();
    }

    function evaluateTimelines() {
      const evalDiv = document.getElementById('evaluation');

      const activeTimelines = timelines.filter(t => !t.ignored);

      if (activeTimelines.length < 2) {
        evalDiv.className = 'evaluation visible';
        evalDiv.innerHTML = '<h3>Consensus</h3><p class="no-consensus">Need at least 2 non-ignored timelines to evaluate</p>';
        return;
      }

      const consensus = [];
      const cellLabels = [];
      rows.forEach(row => {
        cols.forEach(col => {
          cellLabels.push(col + row);
        });
      });

      for (let i = 0; i < 20; i++) {
        const tags = activeTimelines.map(t => t.cellStates[i]).filter(s => s === 1 || s === 2);
        if (tags.length === activeTimelines.length) {
          const allSame = tags.every(t => t === tags[0]);
          if (allSame) {
            consensus.push({ cell: cellLabels[i], state: tags[0] });
          }
        }
      }

      evalDiv.className = 'evaluation visible';
      if (consensus.length === 0) {
        evalDiv.innerHTML = '<h3>Consensus</h3><p class="no-consensus">No cells tagged the same across all non-ignored timelines</p>';
      } else {
        let html = '<h3>Consensus</h3><div class="consensus-list">';
        consensus.forEach(c => {
          const cls = c.state === 1 ? 'green' : 'red';
          html += `<span class="consensus-item ${cls}" onclick="applyConsensus('${c.cell}', ${c.state})">${c.cell}</span>`;
        });
        html += '</div>';
        evalDiv.innerHTML = html;
      }
    }

    function applyConsensus(cellLabel, state) {
      const col = cellLabel.charCodeAt(0) - 65; // A=0, B=1, C=2, D=3
      const row = parseInt(cellLabel.slice(1)) - 1; // 1-5 -> 0-4
      const cellIndex = row * 4 + col;
      const solvedState = state === 1 ? 3 : 4; // green->innocent, red->criminal
      timelines.forEach((_, i) => setCellState(i, cellIndex, solvedState));
      save();
      evaluateTimelines();
    }

    function rerender() {
      document.getElementById('timelines').innerHTML = '';
      timelines.forEach((t, i) => renderTimeline(i, t.cellStates, t.name, t.bgColor));
    }

    let hoveredCell = null;
    let hoveredTimeline = null;

    document.querySelectorAll('.cell').forEach(cell => {
      cell.addEventListener('mouseenter', () => {
        hoveredCell = cell;
        hoveredTimeline = parseInt(cell.closest('.timeline').dataset.index);
      });
      cell.addEventListener('mouseleave', () => {
        hoveredCell = null;
        hoveredTimeline = null;
      });
    });

    function setupCellHover() {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.onmouseenter = () => {
          hoveredCell = cell;
          hoveredTimeline = parseInt(cell.closest('.timeline').dataset.index);
        };
        cell.onmouseleave = () => {
          hoveredCell = null;
          hoveredTimeline = null;
        };
      });
    }

    document.addEventListener('keydown', (e) => {
      if (!hoveredCell || hoveredTimeline === null) return;

      const keyMap = { 'q': 1, 'e': 2, 'a': 3, 'd': 4, ' ': 0 };
      const state = keyMap[e.key.toLowerCase()];

      if (state !== undefined) {
        e.preventDefault();
        const currentState = parseInt(hoveredCell.dataset.state);
        const newState = (currentState === state) ? 0 : state;
        const cellIndex = parseInt(hoveredCell.dataset.cell);

        if (e.shiftKey) {
          timelines.forEach((_, i) => setCellState(i, cellIndex, newState));
        } else {
          setCellState(hoveredTimeline, cellIndex, newState);
        }
        save();
        evaluateTimelines();
      }
    });

    const origRender = renderTimeline;
    renderTimeline = function(index, cellStates, name, bgColor) {
      origRender(index, cellStates, name, bgColor);
      setupCellHover();
    };

    load();
  </script>
</body>
</html>
